<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Fair Squares – Shared Regions + Explanations</title>

<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0;
    display: flex;
    flex-direction: column;
    height: 100vh;
  }

  header {
    background: #1e88e5;
    color: white;
    padding: 10px 16px;
  }

  main {
    display: flex;
    flex: 1;
    overflow: hidden;
  }

  #sidebar {
    width: 260px;
    border-right: 1px solid #ccc;
    padding: 10px;
    box-sizing: border-box;
  }

  #grid-container {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #f5f5f5;
  }

  /* 6×6 grid, 90px cells */
  #grid {
    display: grid;
    grid-template-columns: repeat(6, 90px);
    grid-template-rows: repeat(6, 90px);
    gap: 4px;
  }

  .cell {
    width: 90px;
    height: 90px;
    background: #eee;
    border: 1px solid #bbb;
    position: relative;
    cursor: pointer;
  }

  .outer {
    position: absolute;
    inset: 0;
    background: #d0d0d0;
  }

  .inner {
    position: absolute;
    width: 40%;
    height: 40%;
    top: 30%;
    left: 30%;
    background: white;
    border: 2px solid black;
  }

  .quad {
    position: absolute;
    background: transparent;
  }

  .quad.top {
    top: 0;
    left: 25%;
    width: 50%;
    height: 25%;
  }

  .quad.bottom {
    bottom: 0;
    left: 25%;
    width: 50%;
    height: 25%;
  }

  .quad.left {
    top: 25%;
    left: 0;
    width: 25%;
    height: 50%;
  }

  .quad.right {
    top: 25%;
    right: 0;
    width: 25%;
    height: 50%;
  }

  .dot {
    width: 10px;
    height: 10px;
    background: black;
    border-radius: 50%;
    position: absolute;
    cursor: grab;
  }

  /* Selected dot (tap-to-move) */
  .dot.selected {
    outline: 2px solid #1e88e5;
    outline-offset: 2px;
  }

  .fair {
    outline: 3px solid #43a047;
  }

  .unfair {
    outline: 3px solid #e53935;
  }

  #messages {
    font-size: 13px;
    margin-top: 10px;
    max-height: 40vh;
    overflow-y: auto;
    white-space: pre-line;
    border: 1px solid #ddd;
    padding: 4px;
  }

  #actions button {
    margin-top: 6px;
    padding: 6px 10px;
    font-size: 14px;
  }

  /* Shared region glow overlays */
  .glow {
    position: absolute;
    pointer-events: none;
    border-radius: 4px;
    opacity: 0.7;
    animation: pulse 1.6s infinite ease-in-out;
  }

  /* Soft inner pulse (Intensity 1) */
  @keyframes pulse {
    0%   { box-shadow: inset 0 0 2px rgba(0,0,0,0.2); }
    50%  { box-shadow: inset 0 0 10px rgba(0,0,0,0.4); }
    100% { box-shadow: inset 0 0 2px rgba(0,0,0,0.2); }
  }

  .glow.green  { background: rgba(0, 255, 0, 0.25); }
  .glow.red    { background: rgba(255, 0, 0, 0.25); }
  .glow.yellow { background: rgba(255, 255, 0, 0.25); }

  /* Popup modal */
  #popup-bg {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.4);
    display: none;
    justify-content: center;
    align-items: center;
  }

  #popup {
    background: white;
    padding: 20px;
    width: 320px;
    border-radius: 8px;
    box-shadow: 0 0 12px rgba(0,0,0,0.4);
  }

  #popup h3 {
    margin-top: 0;
  }

  #popup button {
    margin-top: 12px;
    padding: 6px 10px;
  }
</style>
</head>

<body>
<header>
  <h2>Fair Squares – Shared Regions + Explanations</h2>
</header>

<main>
  <aside id="sidebar">
    <h3>Actions</h3>
    <div id="actions">
      <button id="checkBtn">Check Fairness</button>
      <button id="toggleSharedBtn">Show Shared Regions</button>
      <button id="clearBtn">Clear Grid</button>
    </div>

    <h3>Messages</h3>
    <div id="messages"></div>
  </aside>

  <section id="grid-container">
    <div id="grid"></div>
  </section>
</main>

<!-- Popup -->
<div id="popup-bg">
  <div id="popup">
    <h3>Why is this unfair?</h3>
    <div id="popup-content"></div>
    <button id="popup-close">Close</button>
  </div>
</div>

<script>

/* ------------------------------
   DATA + INITIALIZATION
------------------------------ */

const GRID_ROWS = 6;
const GRID_COLS = 6;

// Default dot distributions [top, right, bottom, left]
const defaultPatterns = {
  1: [1,0,0,0],
  2: [1,1,0,0],
  3: [1,1,1,0],
  4: [1,1,1,1],
  5: [2,1,1,1],
  6: [2,2,1,1],
  7: [2,2,2,1],
  8: [2,2,2,2]
};

// Opposite quadrants: top-bottom, right-left
const opposite = { 0:2, 1:3, 2:0, 3:1 };

const gridEl = document.getElementById("grid");
const messagesEl = document.getElementById("messages");
const checkBtn = document.getElementById("checkBtn");
const clearBtn = document.getElementById("clearBtn");
const toggleSharedBtn = document.getElementById("toggleSharedBtn");

const popupBg = document.getElementById("popup-bg");
const popupContent = document.getElementById("popup-content");
const popupClose = document.getElementById("popup-close");

// Data model: each cell has n (1–8 or null) and dots [top, right, bottom, left]
const squares = [];
const fairnessDetails = [];
let sharedOverlayOn = false;

// Tap-to-move selection state
let selectedDot = null;

function clearSelectedDot() {
  if (selectedDot) {
    selectedDot.classList.remove("selected");
    selectedDot = null;
  }
}

// Initialize grid data
for (let r = 0; r < GRID_ROWS; r++) {
  squares[r] = [];
  fairnessDetails[r] = [];
  for (let c = 0; c < GRID_COLS; c++) {
    squares[r][c] = { n: null, dots: [0,0,0,0] };
    fairnessDetails[r][c] = null;
  }
}

/* ------------------------------
   GRID CREATION
------------------------------ */

for (let r = 0; r < GRID_ROWS; r++) {
  for (let c = 0; c < GRID_COLS; c++) {
    const cell = document.createElement("div");
    cell.className = "cell";
    cell.dataset.row = r;
    cell.dataset.col = c;

    cell.addEventListener("click", (e) => {
      // If clicking a dot, don't cycle N or open popup
      if (e.target.classList.contains("dot")) return;

      // If unfair and explanation exists, show popup
      if (cell.classList.contains("unfair") && fairnessDetails[r][c]) {
        showUnfairPopup(r, c);
        return;
      }

      // Otherwise, cycle the square
      cycleSquare(r, c, cell);
    });

    gridEl.appendChild(cell);
  }
}

/* ------------------------------
   RENDERING + DOT MOVEMENT
------------------------------ */

function cycleSquare(r, c, cellEl) {
  let sq = squares[r][c];
  let n = sq.n;

  if (n === null) {
    sq.n = 1;
    sq.dots = defaultPatterns[1].slice();
  } else if (n < 8) {
    sq.n++;
    sq.dots = defaultPatterns[sq.n].slice();
  } else {
    sq.n = null;
    sq.dots = [0,0,0,0];
  }

  renderCell(r, c, cellEl);
  clearHighlights();
  if (sharedOverlayOn) drawSharedOverlay();
}

function renderCell(r, c, cellEl) {
  cellEl.innerHTML = "";

  const sq = squares[r][c];
  if (sq.n === null) return;

  const outer = document.createElement("div");
  outer.className = "outer";

  const inner = document.createElement("div");
  inner.className = "inner";

  const quads = [
    makeQuad("top", 0, r, c),
    makeQuad("right", 1, r, c),
    makeQuad("bottom", 2, r, c),
    makeQuad("left", 3, r, c)
  ];

  quads.forEach((quad, i) => {
    const orientation = (i === 1 || i === 3) ? "vertical" : "horizontal";
    renderDotsInQuadrant(r, c, quad, sq.dots[i], orientation);
    outer.appendChild(quad);
  });

  outer.appendChild(inner);
  cellEl.appendChild(outer);
}

function makeQuad(name, index, r, c) {
  const quad = document.createElement("div");
  quad.className = "quad " + name;
  quad.dataset.quad = index;

  /* Desktop drag-over */
  quad.addEventListener("dragover", (e) => {
    if (!selectedDot) e.preventDefault();
  });

  /* Desktop drop */
  quad.addEventListener("drop", (e) => {
    if (selectedDot) return; // drag disabled while selected
    e.preventDefault();
    const fromQuad = parseInt(e.dataTransfer.getData("from-quad"), 10);
    const row = parseInt(e.dataTransfer.getData("row"), 10);
    const col = parseInt(e.dataTransfer.getData("col"), 10);
    if (row === r && col === c) moveDot(r, c, fromQuad, index);
  });

  /* Tap-to-move */
  quad.addEventListener("click", (e) => {
    e.stopPropagation();   // ← FIX: prevents cycling the square

    if (!selectedDot) return;

    const fromQuad = parseInt(selectedDot.parentElement.dataset.quad, 10);
    const toQuad = index;

    const row = parseInt(selectedDot.parentElement.parentElement.parentElement.dataset.row, 10);
    const col = parseInt(selectedDot.parentElement.parentElement.parentElement.dataset.col, 10);

    moveDot(row, col, fromQuad, toQuad);
    clearSelectedDot();
  });

  return quad;
}

function renderDotsInQuadrant(r, c, quad, count, orientation) {
  quad.innerHTML = "";

  for (let i = 0; i < count; i++) {
    const dot = document.createElement("div");
    dot.className = "dot";
    dot.draggable = true;

    // Positioning
    if (orientation === "horizontal") {
      dot.style.left = `${5 + i * 12}px`;
      dot.style.top = "8px";
    } else {
      dot.style.top = `${5 + i * 12}px`;
      dot.style.left = "8px";
    }

    // Desktop drag
    dot.addEventListener("dragstart", (e) => {
      if (selectedDot) {
        e.preventDefault();
        return;
      }
      e.dataTransfer.setData("row", r.toString());
      e.dataTransfer.setData("col", c.toString());
      e.dataTransfer.setData("from-quad", quad.dataset.quad);
    });

    // Tap-to-select
    dot.addEventListener("click", (e) => {
      e.stopPropagation();
      if (selectedDot === dot) {
        clearSelectedDot();
      } else {
        clearSelectedDot();
        selectedDot = dot;
        dot.classList.add("selected");
      }
    });

    quad.appendChild(dot);
  }
}

function moveDot(r, c, fromQuad, toQuad) {
  const sq = squares[r][c];

  if (sq.dots[fromQuad] > 0) {
    sq.dots[fromQuad]--;
    sq.dots[toQuad]++;
    const cellEl = gridEl.children[r * GRID_COLS + c];
    renderCell(r, c, cellEl);
    clearHighlights();
    if (sharedOverlayOn) drawSharedOverlay();
  }
}

/* ------------------------------
   CLEARING
------------------------------ */

function clearGrid() {
  for (let r = 0; r < GRID_ROWS; r++) {
    for (let c = 0; c < GRID_COLS; c++) {
      squares[r][c].n = null;
      squares[r][c].dots = [0,0,0,0];
      fairnessDetails[r][c] = null;

      const cellEl = gridEl.children[r * GRID_COLS + c];
      cellEl.innerHTML = "";
      cellEl.classList.remove("fair", "unfair");
    }
  }
  messagesEl.textContent = "";
  clearSharedOverlay();
}

function clearHighlights() {
  Array.from(gridEl.children).forEach(cell => {
    cell.classList.remove("fair", "unfair");
  });
  for (let r = 0; r < GRID_ROWS; r++) {
    for (let c = 0; c < GRID_COLS; c++) {
      fairnessDetails[r][c] = null;
    }
  }
}

/* Deselect dot when tapping outside */
document.body.addEventListener("click", (e) => {
  if (!e.target.classList.contains("dot")) {
    clearSelectedDot();
  }
});

/* ------------------------------
   FAIRNESS CHECK (Option C)
------------------------------ */

function checkFairness() {
  clearHighlights();
  let report = "";

  for (let r = 0; r < GRID_ROWS; r++) {
    for (let c = 0; c < GRID_COLS; c++) {
      const sq = squares[r][c];
      fairnessDetails[r][c] = null;

      if (sq.n === null) continue;

      let fair = true;
      let reasons = [];

      const ownTotal = sq.dots.reduce((a,b)=>a+b,0);
      let sharedTotal = 0;
      let hasNeighbor = false;
      let hasValidSharedRegion = false;

      const neighbors = [
        { dr:-1, dc:0, quad:0 },
        { dr:0, dc:1, quad:1 },
        { dr:1, dc:0, quad:2 },
        { dr:0, dc:-1, quad:3 }
      ];

      for (const nb of neighbors) {
        const nr = r + nb.dr;
        const nc = c + nb.dc;
        if (nr < 0 || nr >= GRID_ROWS || nc < 0 || nc >= GRID_COLS) continue;

        const other = squares[nr][nc];
        if (other.n === null) continue;

        hasNeighbor = true;

        const myDots = sq.dots[nb.quad];
        const theirDots = other.dots[opposite[nb.quad]];

        const match = (myDots === theirDots);
        const nonEmpty = (myDots + theirDots > 0);

        if (match && nonEmpty) {
          hasValidSharedRegion = true;
        }

        if (!match) {
          fair = false;
          reasons.push(`Adjacent quadrants mismatch: mine=${myDots}, neighbour=${theirDots}.`);
        }

        if (!nonEmpty) {
          if (sq.n !== 1) {
            fair = false;
            reasons.push(`Empty shared region with neighbour at (${nr+1},${nc+1}).`);
          } else {
            reasons.push(`Empty shared region (allowed for 1-square if fairness achieved).`);
          }
        }

        sharedTotal += theirDots;
      }

      const finalTotal = ownTotal + sharedTotal;
      const target = (sq.n === 1 ? 2 : 8);

      if (sq.n === 1) {
        if (!hasNeighbor) {
          fair = false;
          reasons.push("1-square has no neighbour to share with.");
        }

        if (!hasValidSharedRegion) {
          fair = false;
          reasons.push("1-square has no valid shared region.");
        }

        if (finalTotal !== 2) {
          fair = false;
          reasons.push(`1-square total markers = ${finalTotal}, required = 2.`);
        } else {
          // If the total is correct, drop the "empty shared region" warnings
          reasons = reasons.filter(r => !r.includes("Empty shared region"));
        }
      } else {
        if (finalTotal !== 8) {
          fair = false;
          reasons.push(`Total markers = ${finalTotal}, required = 8.`);
        }
      }

      const cellEl = gridEl.children[r * GRID_COLS + c];
      if (fair) {
        cellEl.classList.add("fair");
        report += `(${r+1},${c+1}) FAIR\n`;
      } else {
        cellEl.classList.add("unfair");
        fairnessDetails[r][c] = {
          ownTotal,
          sharedTotal,
          finalTotal,
          target,
          reasons
        };
        report += `(${r+1},${c+1}) UNFAIR\n`;
      }
    }
  }

  messagesEl.textContent = report || "No squares placed.";
  if (sharedOverlayOn) drawSharedOverlay();
}

/* ------------------------------
   SHARED REGION GLOW
------------------------------ */

function drawSharedOverlay() {
  clearSharedOverlay();

  for (let r = 0; r < GRID_ROWS; r++) {
    for (let c = 0; c < GRID_COLS; c++) {
      const sq = squares[r][c];
      if (sq.n === null) continue;

      const cellEl = gridEl.children[r * GRID_COLS + c];

      const neighbors = [
        { dr:-1, dc:0, quad:0, x:25, y:0,  w:50, h:12 },
        { dr:0,  dc:1, quad:1, x:58, y:25, w:12, h:50 },
        { dr:1, dc:0, quad:2, x:25, y:58, w:50, h:12 },
        { dr:0,  dc:-1, quad:3, x:0,  y:25, w:12, h:50 }
      ];

      for (const nb of neighbors) {
        const nr = r + nb.dr;
        const nc = c + nb.dc;
        if (nr < 0 || nr >= GRID_ROWS || nc < 0 || nc >= GRID_COLS) continue;

        const other = squares[nr][nc];
        if (other.n === null) continue;

        const myDots = sq.dots[nb.quad];
        const theirDots = other.dots[opposite[nb.quad]];

        let color = "yellow";
        if (myDots === theirDots && myDots + theirDots > 0) color = "green";
        if (myDots !== theirDots) color = "red";

        const glow = document.createElement("div");
        glow.className = `glow ${color}`;
        glow.style.left = nb.x + "%";
        glow.style.top = nb.y + "%";
        glow.style.width = nb.w + "%";
        glow.style.height = nb.h + "%";

        cellEl.appendChild(glow);
      }
    }
  }
}

function clearSharedOverlay() {
  const glows = document.querySelectorAll(".glow");
  glows.forEach(g => g.remove());
}

/* ------------------------------
   POPUP EXPLANATIONS
------------------------------ */

function showUnfairPopup(r, c) {
  const details = fairnessDetails[r][c];
  if (!details) return;

  const { ownTotal, sharedTotal, finalTotal, target, reasons } = details;

  let html = "";
  html += `<p><strong>Position:</strong> row ${r+1}, column ${c+1}</p>`;
  html += `<p><strong>Own markers:</strong> ${ownTotal}</p>`;
  html += `<p><strong>Shared from neighbours:</strong> ${sharedTotal}</p>`;
  html += `<p><strong>Total counted markers:</strong> ${finalTotal}</p>`;
  html += `<p><strong>Required total:</strong> ${target}</p>`;

  if (reasons.length > 0) {
    html += `<p><strong>Reasons:</strong></p><ul>`;
    reasons.forEach(rsn => html += `<li>${rsn}</li>`);
    html += `</ul>`;
  }

  popupContent.innerHTML = html;
  popupBg.style.display = "flex";
}

popupClose.addEventListener("click", () => {
  popupBg.style.display = "none";
});

popupBg.addEventListener("click", (e) => {
  if (e.target === popupBg) popupBg.style.display = "none";
});

/* ------------------------------
   BUTTONS
------------------------------ */

toggleSharedBtn.addEventListener("click", () => {
  sharedOverlayOn = !sharedOverlayOn;
  if (sharedOverlayOn) {
    toggleSharedBtn.textContent = "Hide Shared Regions";
    drawSharedOverlay();
  } else {
    toggleSharedBtn.textContent = "Show Shared Regions";
    clearSharedOverlay();
  }
});

checkBtn.addEventListener("click", checkFairness);
clearBtn.addEventListener("click", clearGrid);

</script>
</body>
</html>
